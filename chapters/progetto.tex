\chapter{Progetto}
\label{cha:Progetto}

\section{Descrizione}
Il progetto in questione é un semplice reverse proxy realizzato nel linguaggio di programmazione go e poi containerizzato tramite docker. Il reverse proxy sviluppato effettua alcune delle funzionalitá basi necessarie per la comunicazione. Le funzionalitá implementate sono quindi quelle di routing, supporto a https e wss tramite TLS, configurazione tramite file json.

\section{Obiettivi}
\subsection{Implementativi}
L'obiettivo principale di questo progetto era quello di creare un software che riuscisse a funzionare con comunicazioni http. La lista degli obiettivi inizialmente quindi era:
\begin{enumerate}
  \item supporto http
  \item configurazione via file
  \item sistema di logging per il controllo di eventuali errori
\end{enumerate}
Durante l'implementazione peró ho visto che go ha delle librerie molto ben fornite per lo sviluppo di server e comunque della gestione dei protocolli di comunicazione. Quindo ho visto la possibilitá di ampliare la lista degli obiettivi cercando di includere anche tecnologie nuove come http3. La lista degli obiettivi finali quindi é diventata:
\begin{enumerate}
  \item supporto http/https
  \item supporto websocket (ws/wss)
  \item configurazione via file
  \item chunk encoding
  \item supporto dei subdomain
  \item supporto http2
  \item supporto http3 (anche se non perfettamente funzionante)
  \item sistema di logging per il controllo di eventuali errori
\end{enumerate}

\subsection{Conoscenze}
L'obiettivo principale che ha fatto nascere questo progetto era l'interesse mio nell'approfondire e mettere in pratica le nozioni apprese in materia di comunicazioni web nei corsi che ho frequentato. Anche la scelta del linguaggio di programmazione go é stata fatta con lo scopo di imparare un linguaggio di programmazione che sta diventando via via sempre piú popolare nello sviluppo di server o applicativi che hanno a che fare con il networking. Questo grazie alla sua natura di basso livello che lo rende molto veloce nell'esecuzione ma anche alla vasta varietá di librerie standart che velocizzano molto lo sviluppo, lasciando spazio all'implementazione di nuove feature. Questo sará anche un punto a favore nel mioprogetto perché mi ha lasciato spazio per testare e provare piú funzionalitá di quelle che avevo previsto.

\section{Struttura}
Il progetto é stato strutturato con una struttura base ampliamente utilizzata nei progetti in go che consiste nel dividere i file di programmazione in file interni o file eseguibili. Nei file interni ci sono tutte le funzioni di supporto che poi verranno utilizzate per far funzionare i comandi eseguibili.
\subsection{Schema ad albero}
\begin{verbatim}
- cmd
   - reverse_proxy
- configuration.json
- Dockerfile
- go.mod
- go.sum
- internal
   - http_handler
   - read_configuration
   - reverse_proxy
   - run_server
   - websocket_handler
- test
\end{verbatim}
\subsection{descrizione elementi}
\begin{itemize}[label={}]
  \item \textbf{cmd}: cartella dove vengono inseriti i file eseguibili, in questo caso l'unico comando eseguibile é \texttt{reverse\_proxy}
  \item \textbf{configuration.json}: nel file di configurazione vengono definiti i server da abilitare, le caratteristiche del server e tutte le impostazioni di routing.
  \item \textbf{Dockerfile}: file di configurazione del container docker
  \item \textbf{go.mod, go.sum}: file di configurazione dell'ambiente di sviluppo go.
  \item \textbf{internal}: cartella in cui vengono definite le funzioni che verranno eseguite dal reverse proxy.
  \item \textbf{test}: cartella con tutti i file di test
\end{itemize}

\section{Configurazione}

\subsection{Struttura file configurazione}
\begin{lstlisting}[language=Javascript]
  {
    "servers": [
        {
            "port": int,
            "server_name": string,
            "http3": bool,
            "ssl_to_client": bool,
            "ssl_certificate": string,
            "ssl_certificate_key": string,
            "max_redirect": int,
            "chunk_encoding": bool,
            "chunk_size": int,
            "chunk_timeout": int,
            "location": [
                {
                    "subdomain": string,
                    "to": string
                },
            ]
        }
    ]
}
\end{lstlisting}


