\chapter{Progetto}
\label{cha:Progetto}

\section{Descrizione}
Il progetto in questione é un semplice reverse proxy realizzato nel linguaggio di programmazione go e poi containerizzato tramite docker. Il reverse proxy sviluppato effettua alcune delle funzionalitá basi necessarie per la comunicazione. Le funzionalitá implementate sono quindi quelle di routing, supporto a https e wss tramite TLS, configurazione tramite file json.

\section{Obiettivi}
\subsection{Implementativi}
L'obiettivo principale di questo progetto era quello di creare un software che riuscisse a funzionare con comunicazioni http. La lista degli obiettivi inizialmente quindi era:
\begin{enumerate}
  \item supporto http
  \item configurazione via file
  \item sistema di logging per il controllo di eventuali errori
\end{enumerate}
Durante l'implementazione peró ho visto che go ha delle librerie molto ben fornite per lo sviluppo di server e comunque della gestione dei protocolli di comunicazione. Quindo ho visto la possibilitá di ampliare la lista degli obiettivi cercando di includere anche tecnologie nuove come http3. La lista degli obiettivi finali quindi é diventata:
\begin{enumerate}
  \item supporto http/https
  \item supporto websocket (ws/wss)
  \item configurazione via file
  \item chunk encoding
  \item supporto dei subdomain
  \item supporto http2
  \item supporto http3 (anche se non perfettamente funzionante)
  \item sistema di logging per il controllo di eventuali errori
\end{enumerate}

\subsection{Conoscenze}
L'obiettivo principale che ha fatto nascere questo progetto era l'interesse mio nell'approfondire e mettere in pratica le nozioni apprese in materia di comunicazioni web nei corsi che ho frequentato. Anche la scelta del linguaggio di programmazione go é stata fatta con lo scopo di imparare un linguaggio di programmazione che sta diventando via via sempre piú popolare nello sviluppo di server o applicativi che hanno a che fare con il networking. Questo grazie alla sua natura di basso livello che lo rende molto veloce nell'esecuzione ma anche alla vasta varietá di librerie standart che velocizzano molto lo sviluppo, lasciando spazio all'implementazione di nuove feature. Questo sará anche un punto a favore nel mioprogetto perché mi ha lasciato spazio per testare e provare piú funzionalitá di quelle che avevo previsto.

\section{Struttura}
Il progetto é stato strutturato con una struttura base ampliamente utilizzata nei progetti in go che consiste nel dividere i file di programmazione in file interni o file eseguibili. Nei file interni ci sono tutte le funzioni di supporto che poi verranno utilizzate per far funzionare i comandi eseguibili.
\subsection{Schema ad albero}
\begin{verbatim}
- cmd
   - reverse_proxy
- configuration.json
- Dockerfile
- go.mod
- go.sum
- internal
   - http_handler
   - read_configuration
   - reverse_proxy
   - run_server
   - websocket_handler
- test
\end{verbatim}
\subsection{descrizione elementi}
\begin{itemize}[label={}]
  \item \textbf{cmd}: cartella dove vengono inseriti i file eseguibili, in questo caso l'unico comando eseguibile é \texttt{reverse\_proxy}
  \item \textbf{configuration.json}: nel file di configurazione vengono definiti i server da abilitare, le caratteristiche del server e tutte le impostazioni di routing.
  \item \textbf{Dockerfile}: file di configurazione del container docker
  \item \textbf{go.mod, go.sum}: file di configurazione dell'ambiente di sviluppo go.
  \item \textbf{internal}: cartella in cui vengono definite le funzioni che verranno eseguite dal reverse proxy.
  \item \textbf{test}: cartella con tutti i file di test
\end{itemize}

\section{Configurazione}

\subsection{Struttura file configurazione}
\begin{lstlisting}[language=Javascript]
  {
    "servers": [
        {
            "port": int,
            "server_name": string,
            "http3": bool,
            "ssl_to_client": bool,
            "ssl_certificate": string,
            "ssl_certificate_key": string,
            "max_redirect": int,
            "chunk_encoding": bool,
            "chunk_size": int,
            "chunk_timeout": int,
            "location": [
                {
                    "subdomain": string,
                    "to": string
                },
            ]
        }
    ]
}
\end{lstlisting}
\subsection{Descrizione}
\begin{itemize}[label={}]
  \item \textbf{servers}: Lista dei server che si vogliono avviare all'avviamento del programma.
  \item \textbf{port}: Parta di accesso al server.
  \item \textbf{server\_name}: dominio del server.
  \item \textbf{http3}: Abilitare o no il server anche in modalitá http3.
  \item \textbf{ssl\_to\_client}: Abilitare o no la criptazione dei messaggi da reverse proxy a client.
  \item \textbf{ssl\_certificate}: Percorso del certificato ssl.
  \item \textbf{ssl\_certificate\_key}: Percorso della chiave del certificato.
  \item \textbf{chunk\_encoding}: Impostare l'invio dei dati in pacchetti per diminuire la dimensione di ognuno.
  \item \textbf{chunk\_size}: grandezza del pacchetto.
  \item \textbf{chunk\_timeout}: tempo entro la quale il pacchetto viene inviato anche se non ha raggiunto la dimensione definita da \texttt{chunk\_size}.
  \item \textbf{location}: Lista delle direttive di routing in base al sottodominio.
  \item \textbf{subdomain}: Indica il sottodominio che poi viene collegato al server dietro a \texttt{to}.
  \item \textbf{to}: Locazione del server a cui vengono inviate le richieste mandate tramite il sottodominio definito precedentemente.
\end{itemize}

\section{Implementazione}
\subsection{Lettura file configurazione}
Essendo il file di configurazione un json, si possono sfruttare le librerie di go per generare una struttura con la stessa struttura definita nella configurazione partendo dal file json. Viene quindi definita la struttura indicando ogni variabile a quale chiave corrisponde.
\begin{lstlisting}[language=Golang]
type Configuration struct {
	Http []Server `json:"servers"`
}
type Server struct {
	Port int `json:"port"`
	ServerName string `json:"server_name"`
	Http3Active bool `json:"http3"`
	Location []Location `json:"location"`
	SslToClient bool `json:"ssl_to_client"`
	SslCertificate string `json:"ssl_certificate"`
	SslCertificateKey string `json:"ssl_certificate_key"`
	MaxRedirect int `json:"max_redirect"`
	ChunkEncoding bool `json:"chunk_encoding"`
	ChunkSize int `json:"chunk_size"`
	ChunkTimeout int `json:"chunk_timeout"`
}

type Location struct {
	Domain string `json:"domain"`
	To string `json:"to"`
}
\end{lstlisting}
Questa struttura viene poi popolata con le informazioni presenti nel file con questa sequenza di funzioni.
\begin{lstlisting}[language=Golang]
var Conf Configuration
jsonFile, err := os.Open(filePath)
byteValue, err := io.ReadAll(jsonFile)
readingJsonErr := json.Unmarshal(byteValue, &Conf)
\end{lstlisting}
Successivamente vengono fatti dei test per effettuare queste verifiche:
\begin{itemize}
  \item Le impostazioni per abilitare la criptografia sono state inserite correttamente.
  \item Non ci sono sottodomini nello stesso server che si sovrappongono.
  \item I valori indicati nel \texttt{chunk\_encoding} non eccedono i limiti.
\end{itemize}

\subsection{Avvio servers}
